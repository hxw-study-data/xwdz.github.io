<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最近]]></title>
    <url>%2F2018%2F04%2F11%2F%E6%9C%80%E8%BF%91%2F</url>
    <content type="text"><![CDATA[此时我刚洗完澡，打开花露水抹了抹腿上被蚊子在公司咬的大包。东搞西搞完了之后，打开电脑，时间已经来到11点40了，印象中已经大半年没有加班到这么晚才回家收拾好自己，马上5月了，到了5月来深圳就满整整四个年头了，我眨了眨眼睛。 加班记忆很清晰，刚工作的时候我特别喜欢加班，为何？没钱，住的条件又差，握手楼，屋里没空调，别提多热了，人又比较胖，心想还不如在公司加班，有空调，还能给领导营造出一种你特别努力的工作状态，美哉。 然而实际情况是啥？ 代码写的烂，下什么班啊接着改BUG，由于代码设计不合理，需求频繁变动导致需要推翻之前架构，频繁返工。 既然已经这样了那就干脆更乱一点吧。懒得管了 拿着一个需求直接开始写，不做需求分析。 以上种种情况下还得按时交货，那肯定得加班。 工作入职了新公司，特别特别小的创业公司，刚好入职的一段时间公司短时间内接了很多项目，服务对方过程中爆发出了一系列问题，老板临时晚上开了个会，会上我表达了一下自己的看法，项目管理上面很乱，很没有章法，服务对象短时间爆发式增长，现有系统架构不稳定，不过想来也是情有可原，毕竟基本都身兼数职，这也就是为什么今天回来的这么晚的原因了。 虽然刚入职不过也算是干了点事，毕竟谁都会背一点技术债，比如以前流程上的不规范，引入新流程，修复潜在漏洞等。 入职不久就启动了一个海外项目，分析完需求之后开始在参考Github上面一些比较出名库的架构，之后用了差不多一周的时间写SDK，基本也是跟自己预估的时间差不多，节奏控制的特别好，基本下班就走。这也是我比较纠结的一个点了，公司基本我走最早，其余都加班，有一个是刚毕业的能力方面可能有所欠缺，加加班也是应该，后来了解到原来其余的都是一起出来创业的 效率加班说明你没有效率 在我看来是这样的，并且非常认同这一句话，如果一天按时完成了工作任务何来加班！ 可是我从创业者角度来看，是这样吗？ 不是 事情做不完。永远做不完 我已入职快一个月了，基本上在coding期间会插进来各种事情，被动的不说，主动方面，由于公司网络库非常老旧，不方便维护，从长远考虑自己写了一个网络库，文档方面又非常散，对外推的时候需要手动给对方，而不是让使用者自主寻找文档，所以自己通过Github pages，找公司要了一个域名，做一个静态网页，管理对外文档，要知道我手上可是有开发任务的，所以比较难专注的去做一件事。 再比如跟我对接的后台，公司基本所有问题都要经他流转，东一下西一下的帮业务处理一些问题，关键还有自己的开发任务。 总之负责的业务越多，精力可能越分散也就无法做好一件事情，出现问题的几率也就越大。 生活关于生活不想说一些生活琐事，而想说说我发生的一些变化。 在工作方面，一个需求动手之前都会想想为何？此事何来？何以见得？ 因为我需要一个合理解释来说服我。 以后再写吧，该睡了 安]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 所谓的动态创建Application的方式]]></title>
    <url>%2F2018%2F04%2F08%2FAndroid%20%E6%89%80%E8%B0%93%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAApplication%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于需求在不调用代码的情况下，完成SDK初始化以及请求广告开屏广告操作。 拿到这个需求的时候很疑惑，为什么不能调用代码，是考虑到接入我们SDK成本太高？不存在的，SDK的接入都会给使用者详细的文档按照文档接入即可。我提出了我的质疑。甚至觉得这是一个伪需求 然而给我的答案仅仅是优化我们的接入方式。(这就是个伪需求) 怎么做当确定了需求之后我立即着手该怎么而后确定了大致思路 在Manifest里面声明SDK的代理Application累，替换原有的Application，当创建SDK的代理类Application的时候手动初始化我们的SDK，然后使用hook方式启动一个SDK内置WelcomeActivity，请求广告吸附在该WelcomeActivit上面，随后控制其Activity声明周期创建/销毁 关联 广告展示/关闭等周期。 我们知道Android Application 创建的方式即在Manifest里面声明一个name属性即可创建代码如下1234567&lt;application android:name=".sample.MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 对应的继承Application则会被调用。 如果要实现所谓的‘动态替换’Application得从这里入手了。 实现首先在Manifest声明自己的Application类 包名(也就是路径)123&lt;meta-data android:name="APPLICATION_NAME" android:value="com.jadx.android.sample.MyApplication" /&gt; 而后application name属性声明成SDK代理类Application1234567&lt;application android:name=".ProxyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 在该代理类里面生成真的Application并且实现一系列代理方法核心代码如下 12345678910111213141516171819202122232425262728@Override public void onCreate() &#123; super.onCreate(); mContext = this; final String name = getAppName(); if (!TextUtils.isEmpty(name)) &#123; try &#123; Class clazz = Class.forName(name); mRealApplication = (Application) clazz.newInstance(); mRealApplication.onCreate(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public String getAppName() &#123; try &#123; ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo( mContext.getPackageName(), PackageManager.GET_META_DATA); if (appInfo.metaData != null) &#123; return appInfo.metaData.getString(APP_NAME_KEY); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; return ""; &#125; 当App启动时会走代理类ProxyApplication的OnCreate方法而后通过Class.forName(“包名.类名”)获得其实例，随后代理其一系列原有方法即可。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OkHttp网络请求的封装]]></title>
    <url>%2F2018%2F04%2F06%2FAndroid-OkHttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Github添加依赖12345678implementation 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'implementation 'com.squareup.okhttp3:okhttp:3.5.0'orcomplie 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'compile 'com.squareup.okhttp3:okhttp:3.5.0' Feature 支持JSON解析CallBack声明泛型即可 UI线程回调 支持文件下载 支持Activity/fragment绑定生命周期 支持自定义解析内容 如功能不够，可拿到原生Client，自定义功能 请求Get123456789101112OkHttpRun.get(GET) .execute(new StringCallBack() &#123; @Override public void onSuccess(Call call, String response) &#123; mTextView.setText(response); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); POST12345678910111213OkHttpRun.post(POST).addParams("name", "xwd") .addParams("pwd", "123") .execute(new JsonCallBack&lt;Token&gt;() &#123; @Override public void onSuccess(Call call, Token response) &#123; mTextView.setText(response.toString()); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 下载文件12345678910111213141516171819202122232425String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + "com.test"; OkHttpRun.get("http://download.kugou.com/download/kugou_android") //path 文件路径 // 文件名称 .execute(new FileCallBack&lt;File&gt;(path, "temp.apk") &#123; @Override protected void onProgressListener(float current, long total) &#123; LOG.w("TAG", "current " + current * 100 + "/" + " " + total); &#125; @Override protected void onFinish(File file) &#123; LOG.w("TAG", "finish"); &#125; @Override protected void onStart() &#123; LOG.w("TAG", "start"); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 解析默认支持Callback如下 StringCallBack JsonCallBack FileCallBack 如需要其他解析扩展，继承AbstractCallBack 即可比如123456789101112public abstract class StringCallBack extends AbstractCallBack&lt;String&gt; &#123; @Override protected String parser(Call call, Response response) throws IOException &#123; final String result = response.body().string(); onSuccess(call, result); return result; &#125; protected abstract void onSuccess(Call call, String response);&#125; 配置OkHttpClient添加拦截器到默认client123456789101112final Interceptor interceptor = new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; ... return chain.proceed(requestBuilder.build()); &#125; &#125;; //最后build一下 HttpManager.getInstance().addInterceptor(interceptor) .addNetworkInterceptor(); .build(); 获取内置OkHttpClient1HttpManager.getInstance().getDefaultClient(); 设置OKHttpClient1HttpManaget.getInstance().setOkHttpClient();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android第三方库源码分析,以及Gradle学习资料(持续更新)]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%B8%80%E4%BA%9BAndroid%E7%AC%AC%E4%B8%89%E6%96%B9Lib%E8%A7%A3%E6%9E%90%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[网络库系列 OKHttp拆轮子系列 OkHttp源码解析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 代理模式]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为其他对象提供一种代理一控制对这个对象的访问。 场景当不想直接访问某个对象或访问某个对象存在着一定困难时就可以通过一个代理对象来间接访问。 Code1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String args[]) &#123; // 通过代理类访问具体执行发送信息对象 ProxyMessage proxy = new ProxyMessage(); proxy.sendMessage("Android"); &#125; //代理类 static class ProxyMessage &#123; final Message mMessage = new Message(); void sendMessage(String type) &#123; if ("Android".equals(type)) &#123; mMessage.sendAndroid(); &#125; else &#123; mMessage.sendIOS(); &#125; &#125; &#125; public static class Message &#123; void sendAndroid() &#123; System.out.println("send Android"); &#125; void sendIOS() &#123; System.out.println("send ios"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android关于LayoutInflater加载布局导致布局宽高失效]]></title>
    <url>%2F2018%2F02%2F26%2FAndroid%E5%85%B3%E4%BA%8ELayoutInflater%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80%E5%AF%BC%E8%87%B4%E5%B8%83%E5%B1%80%E5%AE%BD%E9%AB%98%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[为何宽高失效？想要实现如下效果只需要一个recyclerView里面一个textView即可。 Adapter 代码 123456789101112131415161718192021222324252627282930313233343536373839static class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mStrings = new ArrayList&lt;&gt;(); public MyAdapter(Context context) &#123; mContext = context; for (int i = 0; i &lt; 20; i++) &#123; mStrings.add("" + i); &#125; &#125; @Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); return new MyHolder(view); &#125; @Override public void onBindViewHolder(MyHolder holder, int position) &#123; holder.mTextView.setText(mStrings.get(position)); &#125; @Override public int getItemCount() &#123; return mStrings.size(); &#125; static class MyHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyHolder(View itemView) &#123; super(itemView); mTextView = itemView.findViewById(R.id.text); &#125; &#125; &#125; xml文件如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/black" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:padding="12dp" android:layout_height="wrap_content" android:textColor="@android:color/white" android:gravity="center" android:text="123123"/&gt; &lt;/LinearLayout&gt; 可是实现的效果是这样的 可以看到宽明明是match _ parent但是在这里却变成了wrap_content,即文本长度多长，textView宽度都宽，为什么会失效呢？ 首先一个View的宽高padding什么的失我第一个想到的就是LayoutParams，因为一些xml里面属性都在LayoutParams里面，如果失效了估计是LayoutParams没有set上去。 关于LayoutInflater123LayoutInflater.from(mContext).inflate(R.layout.item_list, null);LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 以上是最为普通使用LayoutInflater加载Layout方式，上面的列子中如果使用了3个参数的方法来加载Layout，也就解决了宽度问题，搞懂了2个参数和3个参数方法的区别也就明白了。 代码如下 12345@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, parent, false); return new MyHolder(view); &#125; 如上也就解决了宽度失效问题，可是为什么呢？ 源码 1234567891011121314/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy. * @return The root View of the inflated hierarchy. If root was supplied, * this is the root View; otherwise it is the root of the inflated * XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; 本质上2个参数的方法也是调用了3个参数的方法。三个参数源码如下 1234567891011121314151617181920212223242526272829303132/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; //解析xml final XmlResourceParser parser = res.getLayout(resource); try &#123; //inflate的地方 return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; * &lt;em&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;For performance * reasons, view inflation relies heavily on pre-processing of XML files * that is done at build time. Therefore, it is not currently possible to * use LayoutInflater with an XmlPullParser over a plain XML file at runtime. * * @param parser XML dom node containing the description of the view * hierarchy. * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... 省略部分代码 if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; // 判断是否是merge标签 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); // 关键点 ViewGroup.LayoutParams params = null; // parent 是否为空 if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied // 创建跟布局的LayoutParams params = root.generateLayoutParams(attrs); // 是否为false 如果是flase则添加到view里面 if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. // 注意到这里如果是true 则会将其View添加到root里面 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ... 省略部分代码 return result; &#125; &#125; 注意看到判断是否MERGE的else分支，里面关键的地方都已经写上注释。 其实也就是说，如果root不是空的话，回去创建LayoutParams，在判断如果attchToRoot参数如果是false，则会setLayoutParams到View里面去。 文章的开头有说到LayoutParams这个类，里面都是一个在xml声明的属性，那我们尝试的从侧门解决一下问题，看如下代码 123456@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); view.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); return new MyHolder(view); &#125; 我手动为其设置了LayoutParams，结果如何呢？如下 一样的。 为什么失效之后又是wrap_content呢？这是因为RecyclerView里面机制如果LayoutParams是空的会给一个默认的LayoutParams。以后有兴趣贴源码。 总结12345// 只会生成View 并不会设置任何属性LayoutInflater.from(mContext).inflate(R.layout.item_list, null);// 如果parent不为空会为其生成LayoutParams属性，// attchToRoot如果为flase则会将LayoutParams Set进去，如果为true，则会添加到root里面LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 分割线这种问题其实在开发中非常常见不过当时解决了之后并没有深究其原因实属不该。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 Builder模式]]></title>
    <url>%2F2018%2F02%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍Builder模式是一步一步创建一个复杂对象的创建型模式，可以更精细的控制对象的构造流程。 使用场景 当初始化一个对象特别复杂，比如说参数多，且很多参数都具有默认值 多个部件或者零件，都可以组装到同一个对象中，但是产生的运行结果又不相同。 实现12345678910111213141516171819202122232425262728293031323334public static class Builder &#123; private ViewStub mEmptyViewStub; private ViewStub mLoadingViewStub; private ViewStub mFailureViewStub; private Context mContext; public Builder(Context context) &#123; mContext = context; &#125; public Builder setEmptyViewId(@LayoutRes int resId) &#123; mEmptyViewStub = new ViewStub(mContext); mEmptyViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingLayoutId(@LayoutRes int resId) &#123; mLoadingViewStub = new ViewStub(mContext); mLoadingViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingFailureId(@LayoutRes int resId) &#123; mFailureViewStub = new ViewStub(mContext); mFailureViewStub.setLayoutResource(resId); return this; &#125; public XwStateLayoutManager build() &#123; return new XwStateLayoutManager(this); &#125; &#125; 以上代码是构建通用布局所需要的零件，所以采用了Builder模式来构建所需要的零件 Android 源码实现可参考AlertDialog.Builder 实现。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxAndroid 常用操作符记录]]></title>
    <url>%2F2018%2F01%2F26%2FRxAndroid-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[map,filter,操作符区别？12345678910111213141516171819202122232425//mapObservable.just(mIntegers). map(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; list) &#123; // 做想做的操作 int number = list.get(i); return nulber == 2; &#125; &#125;).subscribe(new Observer&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Boolean aBoolean) &#123; Log.d("TAG", "A = " + aBoolean); &#125; &#125;); 1234567891011121314151617181920212223//filter Observable.just(mIntegers).filter(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; integers) &#123; final int b = integers.get(3); return b &gt; 10; &#125; &#125;).subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; print("size = " + integers.size()); &#125; &#125;); 注意以上代码结果，无论map操作符结果是ture，还是false，订阅者observer都会收到方法回调。 而filter不一样，如果不满足条件observer是不会收到方法回调。 flatMap1234567891011121314151617181920212223242526Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); flatMap 操作符实际上是一个一对多的转换，结合如上业务代码很好理解 根据token去获取到所有的用户信息，查询大于15岁的的用户信息，最后返回一个用户信息集合给订阅者。 flatMap 会返回一个Obervable流，而不像map操作符返回的是一对一的结果。 线程调度在如上列子中，是一个同步任务列子，如何制定为异步任务的话很可能会导致卡顿，那么这里就需要使用大Rx非常强大的线程调度,并且特别方便。先看如下代码 12345678910111213141516171819202122232425262728Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); 注意两个概念 subscribeOn : 指定其事件产生线程 observeOn : 指定事件消费线程 12.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) 如上两句代码则完成线程的切换工作。 如果存在多个observable事件源如何切换线程?12345678910111213141516171819202122232425262728293031Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); // 省略判断条件 return Observale.just(mGirls).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); 如上代码subscribeOn调用了2次flatMap流指定生产线程为异步线程，而filter流指定了生产线程为主线程最后看一下输出结果： 123com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次. 注意： subscribeOn的调用切换之前的线程。 observeOn的调用切换之后的线程。 observeOn之后，不可再调用subscribeOn 切换线程 看如下代码log如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); return Observable.just(users).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()).observeOn(Schedulers.io()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(new Func1&lt;List&lt;User&gt;, String&gt;() &#123; @Override public String call(List&lt;User&gt; users) &#123; print("3 = " + (Looper.getMainLooper() == Looper.myLooper())); return "1"; &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: 3 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 即使在最后一个map指定subscribeOn线程为IO，打印出来还是在主线程。observeOn之后再次调用 subscribeOn是无效的参考文章 http://blog.csdn.net/jdsjlzx/article/details/51685769]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 带三角形箭头头的指引TipLayout实现]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid-%E5%B8%A6%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%8C%87%E5%BC%95tipLayout%E5%AE%9E%E7%8E%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[如上设计图，要求三角形指示器需要动态对齐上面的文本，需要动态的实现对其三角形。 引用方式123compile 'com.xiaowei:TriangleTipLayout:1.0.1'//orimplementation 'com.xiaowei:TriangleTipLayout:1.0.1' 实现思路准备一个三角形指引的图片即可。先上代码 12345678910111213141516171819202122232425262728final TextPaint textPaint = mTextView.getPaint(); final int textHeight = (int) (textPaint.descent() - textPaint.ascent()); mRect.set(0, DEFAULT_TOP_HEIGHT, getWidth(), getHeight() + textHeight - DEFAULT_TOP_HEIGHT); canvas.drawRect(mRect, mRectPaint); final String text = mTextView.getText().toString(); float left = 0; if (mIsShowTriangle) &#123; if (mGravity == Gravity.LEFT || mGravity == Gravity.START) &#123; LayoutParams layoutParams = (LayoutParams) mTarget.getLayoutParams(); left = mTarget.getLeft() - layoutParams.rightMargin - layoutParams.leftMargin; &#125; else &#123; if (mTarget instanceof TextView) &#123; ViewParent viewParent = mTarget.getParent(); float textWidth = textPaint.measureText(text); if (viewParent instanceof LinearLayout) &#123; final float width = mTarget.getWidth() / 2; left = mTarget.getLeft() + width - (mBitmap.getWidth() / 2); &#125; else if (viewParent instanceof RelativeLayout) &#123; left = mTarget.getLeft() + textWidth / 2; &#125; &#125; else if (mTarget instanceof ImageView) &#123; final float width = mTarget.getWidth(); left = mTarget.getLeft() + (width / 2) - (mBitmap.getWidth() / 2); &#125; &#125; canvas.drawBitmap(mBitmap, left, 0, mBitmapPaint); &#125; &#125; 核心代码如上,其思路是先绘制一个矩形，预留出三角形指示器图片所需要的高度，最后将其三行图片绘制出来。 配置指示器123456mTipsLayout.setRectBackgroundColor(Color.parseColor("#FFF8BE"));mTipsLayout.setTextColor(Color.parseColor("#FF9B33"));mTipsLayout.setTriangleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_triangle_arrow));mTipsLayout.setTriangleGravity(Gravity.START);mTipsLayout.bindView(findViewById(R.id.text2));mTipsLayout.setText("您今日收入已到达10W+，牛逼。保持努力"); 注意：当调用setText之后会invalidate()重新绘制; 实现效果如下: Feature todo About GitHub:Github/xwdz/TriangleTipLayout]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Day]]></title>
    <url>%2F2018%2F01%2F01%2FFirst-Day%2F</url>
    <content type="text"><![CDATA[只有当紫霞仙子离开至尊宝的时候，他才能变孙悟空。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio发布个人开源项目至bintray]]></title>
    <url>%2F2017%2F11%2F12%2FAndroidStudio%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91bintray%2F</url>
    <content type="text"><![CDATA[创建账号创建账号时要注意要用国外邮箱。 使用插件发布 项目根目录 build.gradle 添加引用 1classpath 'com.novoda:bintray-release:0.3.4' library目录下的build.gradle 配置如下信息 1234567891011121314151617181920apply plugin: 'com.android.library'//添加如下引用apply plugin: 'com.novoda.bintray-release'//def siteUrl = 'https://github.com/xwdz/BarChartView'publish &#123; userOrg = 'quinnhuang'//bintray.com的用户名 repoName = 'xw-widget'//远程仓库名字,不指明，默认是上传到maven groupId = 'com.xiaowei'//jcenter上的路径 artifactId = 'barchart-view'//项目名称 publishVersion = '1.0.0'//版本号 desc = '轻量型柱形图'//描述，不重要 website = siteUrl//项目主页&#125;tasks.withType(Javadoc) &#123;//防止编码问题 options.addStringOption('Xdoclint:none', '-quiet') options.addStringOption('encoding', 'UTF-8') options.addStringOption('charSet', 'UTF-8')&#125; 上传至bintray1./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxxx -PdryRun=falser 期间遇到的问题用户名不统一1Could not create version '1.0.0': HTTP/1.1 401 Unauthorized PbintrayUser、userOrg 两者属性属性必须一样，即bintray.com的用户名 lint 检查出来的错误12345android &#123; lintOptions &#123; abortOnError false &#125; &#125; 在你library以及App的build.gradle的androud模块添加 123456789101112131415161718192021222324android &#123; compileSdkVersion 26 buildToolsVersion "26.0.0" defaultConfig &#123; minSdkVersion 21 targetSdkVersion 26 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; // 忽略lint lintOptions &#123; abortOnError false &#125;&#125; 最后add central 等待审核即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说几句话]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%AF%B4%E5%87%A0%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[也许不是因为菜好吃，而是因为陪在身边的人。这句话出自前女友博客，分手不过半月，看到这句话嘴角笑着想起来以前跟她的点点滴滴。 酸菜鱼吃这道菜的时候，是她某次来大理的时候，我找了一家饭馆，吃的酸菜鱼，也是我至今吃过最好吃的酸菜鱼了，便宜，实惠，跟她一起吃的。 放下跟她分手之后，我会经常发牢骚，想找她聊天，又不敢，各种纠结，好不容易跟她说话我都会比较冲会带着小情绪跟她说话。 中午午休的时候前女友给我分享了个博客，我看完之后跟她产生了如下对话： 我：你又勾起我的回忆 她：你只看出这个 我：。。。 我：你分享给我是让我写观后感嘛？ 她：不是啊 她：哈哈哈 她：反正我们都要放下啦 她：你也别再无缘无故跟我发脾气了 当看见着两条信息的时候，心里蹦的一下，曾经那么信任，亲近的一个人，离开了。 大概就是分手了从心底里希望你快乐幸福，This is Love。 即使自己心中有万分不舍也得放下，自己也应该调整好心态。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio .9图]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-studio-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[生成.9图Android Studio 对于.9图的生成也非常友好，直接点击图片右建create.9图； 图片右键 =&gt; Create 9-patch File =&gt; 确定即可，生成.9图之后打开即如见下图 文件名会默认为：xxx.9.png 如上图4条黑线位置构成拉伸区域]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突如其来的国庆总结]]></title>
    <url>%2F2017%2F10%2F05%2F%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[去年辞职尤记得去年裸辞职后，过年回到家，非常不安，毕竟没有工资就没有安全感，年终总结也不想写，只想尽快找到工作，过完年，跟家人匆匆道别，初二就回深圳了，开始为找工作做准备，还记得那短时间，每天10点多起来就开始写自己的项目，大概4.5点以后总结一些知识点，8.9点出门跑跑步，那短日子想起来，也是少有的专注。 找到工作写这篇blog的时候已是国庆放假时期，可是当时面试的日子却还是历历在目。期间总共面试了6家公司，拿到2家offer。 其中5家公司在boss直聘发出邀请，一家在拉钩，而我现在最终选择了在拉钩平台上的公司。李文星事件 工作ing2月21号入职新公司，公司规范的软件流程也让我非常高兴，因为之前的公司是没有走过这么完整的软件开发流程的。 需求掰扯 PRD产出 UI出图 排期 开发 git的使用 git flow工作流 冒泡 提测 改bug 测试回归 UI回归 正式版回归 运营发包 整个产品的生产周期，然后往返循环迭代。 总结手上项目从0-1的开发过程，期间一些没有接触过的功能点的开发，都给自己的实战能力增强不少，比较遗憾的是开发过程中的一些问题都没有记录下来，并且消化，最重要的是胖了，国庆回来都说我胖了… 计划 专业技能不能落下，尽量多产出一些技术文章。 减肥。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 混淆相关]]></title>
    <url>%2F2017%2F10%2F03%2FAndroid-%E6%B7%B7%E6%B7%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[忽略tmp.txt tmp.txt 忽略所有log文件 .log 忽略tmp文件夹所有文件 tmp/* 忽略log目录下的包括子目录下的所有log文件 log/**/*.log 查看项目ＳＨＡ１ ＭＤ５ 值 keytool -v -list -keystore ~/.android/debug.keystore]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令记录]]></title>
    <url>%2F2017%2F10%2F03%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[删除本地分支 git branch -d 分支名 删除未合并分支 git branch -D 分支名 新建本地分支 git branch 分支名 推送分支到服务器 git push origin 本地分支名:服务器分支名 删除远程分支 git push origin --delete &lt;branchName&gt; git 回退commit首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本. 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 $ git reset --hard HEAD^ 版本比对git diff commitMD5 git工作流当release分支结束时，使用gitflow，finish掉分支 git flow release finish &#39;1.1&#39;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
