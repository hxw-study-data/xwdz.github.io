<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxAndroid 常用操作符记录]]></title>
    <url>%2F2018%2F01%2F26%2FRxAndroid-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[几个常用操作符 map,flatMap,filter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//mapObservable.just(mIntegers). map(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; list) &#123; // 做想做的操作 int number = list.get(i); return nulber == 2; &#125; &#125;).subscribe(new Observer&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Boolean aBoolean) &#123; Log.d("TAG", "A = " + aBoolean); &#125; &#125;); //filter Observable.just(mIntegers).filter(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; integers) &#123; final int b = integers.get(3); return b &gt; 10; &#125; &#125;).subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; print("size = " + integers.size()); &#125; &#125;); 注意以上代码结果，无论map操作符结果是ture，还是false，订阅者observer都会收到方法回调。 而filter不一样，如果不满足条件observer是不会收到方法回调。 flatMap1234567891011121314151617181920212223242526Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); flatMap 操作符实际上是一个一对多的转换，结合如上业务代码很好理解 根据token去获取到所有的用户信息，查询大于15岁的的用户信息，最后返回一个用户信息集合给订阅者。 flatMap 会返回一个Obervable流，而不像map操作符返回的是一对一的结果。 线程调度在如上列子中，是一个同步任务列子，如何制定为异步任务的话很可能会导致卡顿，那么这里就需要使用大Rx非常强大的线程调度,并且特别方便。先看如下代码 12345678910111213141516171819202122232425262728Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); 注意两个概念 subscribeOn : 指定其事件产生线程 observeOn : 指定事件消费线程 123456789101112131415161718Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; // 事件产生线程，运行在子线程 for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;). // 指定事件产生线程 subscribeOn(Schedulers.io()). // 订阅者线程也就是事件消费线程 observeOn(AndroidSchedulers.mainThread()) ...... 如上两句代码则完成线程的切换工作。 如果存在多个observable事件源如何切换线程?12345678910111213141516171819202122232425262728293031Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); // 省略判断条件 return Observale.just(mGirls).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); 如上代码subscribeOn调用了2次flatMap流指定生产线程为异步线程，而filter流指定了生产线程为主线程最后看一下输出结果： 123com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次. 注意： subscribeOn的调用切换之前的线程。 observeOn的调用切换之后的线程。 observeOn之后，不可再调用subscribeOn 切换线程 看如下代码log如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); return Observable.just(users).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()).observeOn(Schedulers.io()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(new Func1&lt;List&lt;User&gt;, String&gt;() &#123; @Override public String call(List&lt;User&gt; users) &#123; print("3 = " + (Looper.getMainLooper() == Looper.myLooper())); return "1"; &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: 3 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 即使在最后一个map指定subscribeOn线程为IO，打印出来还是在主线程。observeOn之后再次调用 subscribeOn是无效的参考文章 http://blog.csdn.net/jdsjlzx/article/details/51685769]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 带三角形箭头头的指引TipLayout实现]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid-%E5%B8%A6%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%8C%87%E5%BC%95tipLayout%E5%AE%9E%E7%8E%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[如上设计图，要求三角形指示器需要动态对齐上面的文本，需要动态的实现对其三角形。 引用方式123compile 'com.xiaowei:TriangleTipLayout:1.0.1'//orimplementation 'com.xiaowei:TriangleTipLayout:1.0.1' 实现思路准备一个三角形指引的图片即可。先上代码 12345678910111213141516171819202122232425262728final TextPaint textPaint = mTextView.getPaint(); final int textHeight = (int) (textPaint.descent() - textPaint.ascent()); mRect.set(0, DEFAULT_TOP_HEIGHT, getWidth(), getHeight() + textHeight - DEFAULT_TOP_HEIGHT); canvas.drawRect(mRect, mRectPaint); final String text = mTextView.getText().toString(); float left = 0; if (mIsShowTriangle) &#123; if (mGravity == Gravity.LEFT || mGravity == Gravity.START) &#123; LayoutParams layoutParams = (LayoutParams) mTarget.getLayoutParams(); left = mTarget.getLeft() - layoutParams.rightMargin - layoutParams.leftMargin; &#125; else &#123; if (mTarget instanceof TextView) &#123; ViewParent viewParent = mTarget.getParent(); float textWidth = textPaint.measureText(text); if (viewParent instanceof LinearLayout) &#123; final float width = mTarget.getWidth() / 2; left = mTarget.getLeft() + width - (mBitmap.getWidth() / 2); &#125; else if (viewParent instanceof RelativeLayout) &#123; left = mTarget.getLeft() + textWidth / 2; &#125; &#125; else if (mTarget instanceof ImageView) &#123; final float width = mTarget.getWidth(); left = mTarget.getLeft() + (width / 2) - (mBitmap.getWidth() / 2); &#125; &#125; canvas.drawBitmap(mBitmap, left, 0, mBitmapPaint); &#125; &#125; 核心代码如上,其思路是先绘制一个矩形，预留出三角形指示器图片所需要的高度，最后将其三行图片绘制出来。 配置指示器123456mTipsLayout.setRectBackgroundColor(Color.parseColor("#FFF8BE"));mTipsLayout.setTextColor(Color.parseColor("#FF9B33"));mTipsLayout.setTriangleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_triangle_arrow));mTipsLayout.setTriangleGravity(Gravity.START);mTipsLayout.bindView(findViewById(R.id.text2));mTipsLayout.setText("您今日收入已到达10W+，牛逼。保持努力"); 注意：当调用setText之后会invalidate()重新绘制; 实现效果如下: Feature todo About GitHub:Github/xwdz/TriangleTipLayout]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Day]]></title>
    <url>%2F2018%2F01%2F01%2FFirst-Day%2F</url>
    <content type="text"><![CDATA[只有当紫霞仙子离开至尊宝的时候，他才能变孙悟空。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio发布个人开源项目至bintray]]></title>
    <url>%2F2017%2F11%2F12%2FAndroidStudio%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91bintray%2F</url>
    <content type="text"><![CDATA[创建账号创建账号时要注意要用国外邮箱。 使用插件发布 项目根目录 build.gradle 添加引用 1classpath 'com.novoda:bintray-release:0.3.4' library目录下的build.gradle 配置如下信息 1234567891011121314151617181920apply plugin: 'com.android.library'//添加如下引用apply plugin: 'com.novoda.bintray-release'//def siteUrl = 'https://github.com/xwdz/BarChartView'publish &#123; userOrg = 'quinnhuang'//bintray.com的用户名 repoName = 'xw-widget'//远程仓库名字,不指明，默认是上传到maven groupId = 'com.xiaowei'//jcenter上的路径 artifactId = 'barchart-view'//项目名称 publishVersion = '1.0.0'//版本号 desc = '轻量型柱形图'//描述，不重要 website = siteUrl//项目主页&#125;tasks.withType(Javadoc) &#123;//防止编码问题 options.addStringOption('Xdoclint:none', '-quiet') options.addStringOption('encoding', 'UTF-8') options.addStringOption('charSet', 'UTF-8')&#125; 上传至bintray1./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxxx -PdryRun=falser 期间遇到的问题用户名不统一1Could not create version '1.0.0': HTTP/1.1 401 Unauthorized PbintrayUser、userOrg 两者属性属性必须一样，即bintray.com的用户名 lint 检查出来的错误12345android &#123; lintOptions &#123; abortOnError false &#125; &#125; 在你library以及App的build.gradle的androud模块添加 123456789101112131415161718192021222324android &#123; compileSdkVersion 26 buildToolsVersion "26.0.0" defaultConfig &#123; minSdkVersion 21 targetSdkVersion 26 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; // 忽略lint lintOptions &#123; abortOnError false &#125;&#125; 最后add central 等待审核即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说几句话]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%AF%B4%E5%87%A0%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[也许不是因为菜好吃，而是因为陪在身边的人。这句话出自前女友博客，分手不过半月，看到这句话嘴角笑着想起来以前跟她的点点滴滴。 酸菜鱼吃这道菜的时候，是她某次来大理的时候，我找了一家饭馆，吃的酸菜鱼，也是我至今吃过最好吃的酸菜鱼了，便宜，实惠，跟她一起吃的。 放下跟她分手之后，我会经常发牢骚，想找她聊天，又不敢，各种纠结，好不容易跟她说话我都会比较冲会带着小情绪跟她说话。 中午午休的时候前女友给我分享了个博客，我看完之后跟她产生了如下对话： 我：你又勾起我的回忆 她：你只看出这个 我：。。。 我：你分享给我是让我写观后感嘛？ 她：不是啊 她：哈哈哈 她：反正我们都要放下啦 她：你也别再无缘无故跟我发脾气了 当看见着两条信息的时候，心里蹦的一下，曾经那么信任，亲近的一个人，离开了。 大概就是分手了从心底里希望你快乐幸福，This is Love。 即使自己心中有万分不舍也得放下，自己也应该调整好心态。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio .9图]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-studio-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[生成.9图Android Studio 对于.9图的生成也非常友好，直接点击图片右建create.9图； 图片右键 =&gt; Create 9-patch File =&gt; 确定即可，生成.9图之后打开即如见下图 文件名会默认为：xxx.9.png 如上图4条黑线位置构成拉伸区域]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突如其来的国庆总结]]></title>
    <url>%2F2017%2F10%2F05%2F%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%BD%E5%BA%86%E8%8A%82%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[去年辞职尤记得去年裸辞职后，过年回到家，非常不安，毕竟没有工资就没有安全感，年终总结也不想写，只想尽快找到工作，过完年，跟家人匆匆道别，初二就回深圳了，开始为找工作做准备，还记得那短时间，每天10点多起来就开始写自己的项目，大概4.5点以后总结一些知识点，8.9点出门跑跑步，那短日子想起来，也是少有的专注。 找到工作写这篇blog的时候已是国庆放假时期，可是当时面试的日子却还是历历在目。期间总共面试了6家公司，拿到2家offer。 其中5家公司在boss直聘发出邀请，一家在拉钩，而我现在最终选择了在拉钩平台上的公司。李文星事件 工作ing2月21号入职新公司，公司规范的软件流程也让我非常高兴，因为之前的公司是没有走过这么完整的软件开发流程的。 需求掰扯 PRD产出 UI出图 排期 开发 git的使用 git flow工作流 冒泡 提测 改bug 测试回归 UI回归 正式版回归 运营发包 整个产品的生产周期，然后往返循环迭代。 总结手上项目从0-1的开发过程，期间一些没有接触过的功能点的开发，都给自己的实战能力增强不少，比较遗憾的是开发过程中的一些问题都没有记录下来，并且消化，最重要的是胖了，国庆回来都说我胖了… 计划 专业技能不能落下，尽量多产出一些技术文章。 减肥。]]></content>
      <tags>
        <tag>Lift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 混淆相关]]></title>
    <url>%2F2017%2F10%2F03%2FAndroid-%E6%B7%B7%E6%B7%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[忽略tmp.txt tmp.txt 忽略所有log文件 .log 忽略tmp文件夹所有文件 tmp/* 忽略log目录下的包括子目录下的所有log文件 log/**/*.log 查看项目ＳＨＡ１ ＭＤ５ 值 keytool -v -list -keystore ~/.android/debug.keystore]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令记录]]></title>
    <url>%2F2017%2F10%2F03%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[删除本地分支 git branch -d 分支名 删除未合并分支 git branch -D 分支名 新建本地分支 git branch 分支名 推送分支到服务器 git push origin 本地分支名:服务器分支名 删除远程分支 git push origin --delete &lt;branchName&gt; git 回退commit首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本. 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 $ git reset --hard HEAD^ 版本比对git diff commitMD5 git工作流当release分支结束时，使用gitflow，finish掉分支 git flow release finish &#39;1.1&#39;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
