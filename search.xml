<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最后的唐寅]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9C%80%E5%90%8E%E7%9A%84%E5%94%90%E5%AF%85%2F</url>
    <content type="text"><![CDATA[初识刚温故了电影&lt;唐伯虎点秋香&gt;因为对他最初的印象是从这里产生的直接影响，唐伯虎能文能武，智斗奸臣，抱得美人归，十分搞笑。而如今明白真相之后再看电影，却再也笑不出来。 彻底堕落最后的才子唐伯虎利用装疯，裸奔等方法从朱宸濠(朱宸濠造反需要人才，故想收编唐伯虎，而唐一开始以为是要聘他为太师之类的,知道是造反后想溜，可知道了那么多秘密怎能放你走)虎口脱险松了一口气，但在庆祝劫后余生的同时，他对人生也已经彻底绝望。 日以继夜的饮酒作乐，纵情声色，摧垮了他的身体，却也成就了他的艺术。 但也就到此为止了，1523年这位中国文化历史上的天才结束了自己坎坷的一声归于沉寂。 再看电影时，在我脑海里始终浮现的是那个真实的唐伯虎，在无奈中痛苦挣扎，无比绝望，中年怀才不遇，老年心灰意冷，不禁让人心疼。 桃花歌别人笑我太疯癫， 我笑他人看不穿。 不见五陵豪杰墓， 无花无酒锄作田。]]></content>
      <categories>
        <category>日常侃侃</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[假期之后]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%81%87%E6%9C%9F%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[明天上最后一天班又是周末，舒服！ 开始做饭节后上班到现在每天晚上都做饭带饭，说来已经三天了，本想着会很累，毕竟每天下班到家已经9点多了，可还是坚持自己做了两个菜，不为别的，节前的时候点了个三级第，吃完肚子疼跑了无数次厕所，唉，这次的遭遇也让我彻底的反感外卖，上班到现在以前都是叫外卖，周末从来都是外卖，我这不知道吃了几年地沟油了… 趁着五一的时候放假，去超市买了一百多块钱的菜，想着应该能吃很久了吧，刚开始做得时候由于厨艺生疏，在饭菜质量把控上面，也着实让自己捏了一把汗， 因为我总是炒糊… 做饭上瘾 刚刚炒的菜，是我目前炒的卖相最好的，颜色分明，不像之前炒的大部分都是黑色的，因为有很多地方是糊的… 是因为我没有翻炒而火又比较大直接给糊了。明天有口福了 我为何要表明主题是做饭上瘾呢，是因为我让我自己上瘾的，严格来说是即使自己不想做饭，也逼着自己做，让其成为一种习惯，习惯是不会累的，习惯让自己过得更舒服。 习惯最近我也在恶补英语，自然不会少了背单词这个大工程，当看代码看到注释或者其他地方有不认识的单词，恨一波单词用时方很少啊，便给自己定了计划。 常用单词7500个，每天背30个，那么需要250天把这些单词背完，这其中肯定也会有自己认识的严格来讲不会需要250天。 我是怎么背的一张草稿纸，笔，然后每个单词写上听上个10来遍，如此反复。 这种方式对我来说不错，只需长期坚持。 杂谈最近迷上了本书&lt;明朝那些事&gt;共七册，不得不说作者写的很棒，脉络清楚，虽说是历史，文字却也幽默。以前觉得皇帝陛下很享受，万人之上，后宫佳丽三千，然而皇帝却是一个高危职业，皇帝身边的人更加危险。 对外:来说一旦国家危在旦夕，皇帝怎能苟且，唯有一死 对内:皇帝最难得就是朋友,因为无时无刻都得提防着身边的人，也许哪天醒来已然成为阶下囚。这也是为啥皇帝总是说孤家寡人 心狠在我看来是皇帝的第一要素，朱元璋创业成功以后杀掉自己以前一起打天下的战友，功高盖主可不行，即使你没有，也得杀，保不齐将来对自己产生威胁，正如书里说的，朱元璋要么不做，要么做绝。 最后 ps:本来想分享一下~不过没有版权并不能播放 晚安]]></content>
      <categories>
        <category>日常侃侃</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 观察者模式]]></title>
    <url>%2F2018%2F05%2F01%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式定义对象的一种一对多的依赖关系，使得每当一个改变状态，则所有依赖它的对象都会得到通知并更新 比如之前自己项目，有一个后台下载任务，下载进度要在任何activity都可以收到，此时一对多的观察者模式最好不过了。 Java JDK已经实现了一套观察者模式 根据思路可建如下两个类 DownLoadState 观察者，观察数据源是否改变 DownloadObservable 被观察者，数据源发生改变 Entry 实体类 实体类如下: 12345public class Entry &#123; public String id; public String currentLength;&#125; 定义观察者如下: 12345678910111213141516public abstract class DownLoadState implements Observer &#123; public DownLoadState() &#123; &#125; @Override public void update(Observable observable, Object o) &#123; if (o instanceof Entry) &#123; Entry entry = (Entry) o; updateUi(entry); &#125; &#125; public abstract void updateUi(Entry entry);&#125; 被观察者: 1234567891011121314151617181920212223242526272829public class DownloadObservable extends Observable &#123; private static final DownloadObservable CODER_OBSERVABLE = new DownloadObservable(); public static CoderObservable get() &#123; return CODER_OBSERVABLE; &#125; private CoderObservable() &#123; &#125; public void addDownloadState(DownLoadState downLoadState) &#123; addObserver(downLoadState); &#125; public void removeDownloadState(DownLoadState downLoadState) &#123; deleteObserver(downLoadState); &#125; public void post(String msg) &#123; setChanged(); notifyObservers(msg); &#125;&#125; 测试代码如下: 123456789101112131415161718192021222324252627282930public static void main(String args[])&#123; DownLoadState downLoadState = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownLoadState downLoadState1 = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownLoadState downLoadState2 = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownloadObservable.get().addDownloadState(downLoadState); DownloadObservable.get().addDownloadState(downLoadState1); DownloadObservable.get().addDownloadState(downLoadState2); Entry entry = new Entry(); entry.id = "1"; for (int i = 0; i &lt; 100; i++) &#123; entry.currentLength = String.valueOf(i); CoderObservable.get().post(entry); &#125;&#125; 输出如下： 1234567891011观察者downLoadState2 当前任务ID = 1 接受到更新 = 0观察者downLoadState1 当前任务ID = 1 接受到更新 = 0观察者downLoadState 当前任务ID = 1 接受到更新 = 0观察者downLoadState2 当前任务ID = 1 接受到更新 = 1观察者downLoadState1 当前任务ID = 1 接受到更新 = 1观察者downLoadState 当前任务ID = 1 接受到更新 = 1...观察者downLoadState2 当前任务ID = 1 接受到更新 = 99观察者downLoadState1 当前任务ID = 1 接受到更新 = 99观察者downLoadState 当前任务ID = 1 接受到更新 = 99 总结如上需求，则只需要在需要接受到下载进度条的activity创建的时候调用DownloadObservable.get().addDownloadState方法即可接受，在activity销毁的时候调用DownloadObservable.get().removeDownloadState方法避免内存泄漏问题。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hook基础-动态代理]]></title>
    <url>%2F2018%2F04%2F28%2FHook%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理顾名思义，委托别人来帮助自己完成一些事情。例如打官司是不是要请律师，这样的一种关系就可以叫做代理关系。 静态代理 小明姨妈本想明天约小明妈妈去超市超市大甩卖，不过小姨妈临时需要去学习办点事去，这时小明姨妈委托小明告诉小明妈妈，明天某某超市大甩卖，让小明妈妈明天再门口等小明姨妈一起去超市购物。不过小明不仅告诉了自己妈妈，还告诉了一个不认识的大妈 如此小明便成为一个代理者。 1234public interface SendMessage &#123; void sendMsg(String msg);&#125; 实现类如下 1234567public class SendMessageImpl implements SendMessage &#123; @Override public void sendMsg(String msg) &#123; System.out.println(msg); &#125;&#125; 代理类 1234567891011121314151617181920212223public class ProxySend implements SendMessage &#123; SendMessage mSendMessage; public ProxySend(SendMessage sendMessage) &#123; mSendMessage = sendMessage; &#125; @Override public void sendMsg(String msg) &#123; System.out.println("大妈，隔壁某某超市甩卖了拉，赶紧去买点便宜的东西"); mSendMessage.sendMsg(msg); &#125;&#125;public statis void main(String[] args)&#123; final SendMessage sendMessage = new SendMessageImpl(); ProxySend send = new ProxySend(sendMessage); send.sendMsg("超市大甩卖");&#125; 123输出结果:大妈，隔壁某某超市甩卖了拉，赶紧去买点便宜的东西超市大甩卖 由于静态代理需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？ 使用动态代理则不需要手写每一个静态代理类。 12345678SendMessage proxy = (SendMessage) Proxy.newProxyInstance(sendMessage.getClass().getClassLoader(), sendMessage.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; return method.invoke(sendMessage,objects); &#125; &#125;); proxy.sendMsg("代理类发出信息 超市大甩卖"); 动态代理主要处理InvocationHandler和Proxy类，在InvocationHandler反射调用方法。]]></content>
      <categories>
        <category>android-hook</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hook基础-反射]]></title>
    <url>%2F2018%2F04%2F27%2FHook%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Hook基础-反射通过Class.forName静态方法可以根据类的绝对路径拿到某个类的Class实例 新建测试Test类如下package com.example.lib; public class Test { private String username; private String password; public Test(){ } public int showInfo(String name,String pwd){ MyClass.print(&quot;name = &quot; + name); MyClass.print(&quot;pwd = &quot; + pwd); return 2; } @Override public String toString() { return &quot;Test{&quot; + &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &apos;}&apos;; } } 反射变量public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Field username = cls.getDeclaredField(&quot;username&quot;); username.setAccessible(true); username.set(object,&quot;100&quot;); } 输出 Test{username=&apos;100&apos;, password=&apos;null&apos;} 注意 set(Object var1, Object var2) 方法接收两个参数 var1 : 当前实例var2 : 修改的实例 get(Object var1) 方法接受一个参数 var1 : Field实例 如果没加username.setAccessible(true)则会报错如下 can not access a member of class x.com.lib.Test with modifiers “private” 因为Test里面定义的变量是private的,改成public即可。 如果需要获取到private属性的则需要加username.setAccessible(true)。 public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Field username = cls.getDeclaredField(&quot;username&quot;); username.setAccessible(true); username.set(object,&quot;100&quot;); Field password = cls.getDeclaredField(&quot;password&quot;); password.setAccessible(true); password.set(object,&quot;1234567&quot;); print(object.toString()); } 输出 Test{username=&apos;100&apos;, password=&apos;1234567&apos;} 反射方法 public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); method.invoke(object,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 反射 获取方法返回类型public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); Class&lt;?&gt; returnType = method.getReturnType(); int resulr = method.invoke(object,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 result = 2 returnType = int 注意如果反射的方法是静态方法的话可直接invoke(null,…) public static int showInfo(String name,String pwd){ MyClass.print(&quot;name = &quot; + name); MyClass.print(&quot;pwd = &quot; + pwd); return 2; } public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); Class&lt;?&gt; returnType = method.getReturnType(); int resulr = method.invoke(null,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 result = 2 returnType = int 反射的如果是private属性的一定要注意兼容问题，因为如果别人哪天改了变量名,程序说不定crash了。]]></content>
      <categories>
        <category>android-hook</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石原里美真美]]></title>
    <url>%2F2018%2F04%2F26%2F%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E%E7%9C%9F%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[日剧 非自然死亡看剧过程中随手一截 - -！]]></content>
      <categories>
        <category>日常侃侃</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 使用Activity作为Contenxt启动BroadcastReceiveer的一些问题]]></title>
    <url>%2F2018%2F04%2F17%2FAndroid%20BroadcastReceiveer%E5%BC%95%E7%94%A8context%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[问题背景下载APK的时候需要做一个通知栏并且支持暂停，取消等功能交互。通知栏的UI点击交互用的就是broadcast来接受点击事件 代码如下 registerReceiver(context, MyBroadcastReceiver); Intent intent = new Intent(ACTION); PendingIntent pendingIntent1 = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); mRemoteViews.setOnClickPendingIntent(mRemoteBuild.clickId, pendingIntent1); 伪代码如上就是为通知栏设置点击事件的一种方法。 可当我测试点击的时候我注册的广播里面就是接收不到点击事件。无奈我有改用静态方式来注册广播，观察log发现静态方式是可以接受到点击事件的那看来就是动态注册方式出了问题。于是我开始整理思路。 打开App，显示开屏广告，点击广告下载apk然后再创建通知栏，再更新下载进度。 而后我继续测试，我将组件拿出来新建了一个项目来测试，发现是正常的，而后再次切换到前者项目测试，发现还是不行接受不到广播点击事件。 我对比发现两者的不同点只是在activity的生命周期上面了。 注意开屏广告的activity生命周期只有3s。这点也非常重要。 附一张非常经典的生命周期图。 而我用新建的项目测试的时候有一点是 当前的activity 在下载过程中一直都没有销毁，而项目里面测试的时候是开屏广告activity，生命周期只有3s，3s之后就已经被自动的finish了。 而又我在新建的项目里面继续写测试代码，写了个3s之后自动finish当前activity，果然也报错了，看来就是跟当前生命周期有关，那也就是传过来的context了。 解决办法想了想，解决办法也很简单。因为下载的service要一直在后台运行，所以将传进来的context.getApplicationContext()，去注册广播，销毁广播等，这样就能保证是在整个app运行期间了，也不会造成内存泄漏问题。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notification的一些坑。]]></title>
    <url>%2F2018%2F04%2F12%2FNotifyManager%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[RemoteViews自定义layout支持大图用setCustomBigContentView方法 123if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; notificationBuilder.setCustomBigContentView(mRemoteViews);&#125; 另外Android 华为7.0默认背景颜色白色，是不会显示任何东西的，不过在小米上面又是正常。另外小米以及华为都是默认都有padding值，注意UI方面调整。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近]]></title>
    <url>%2F2018%2F04%2F11%2F%E6%9C%80%E8%BF%91%2F</url>
    <content type="text"><![CDATA[此时我刚洗完澡，打开花露水抹了抹腿上被蚊子在公司咬的大包。东搞西搞完了之后，打开电脑，时间已经来到11点40了，印象中已经大半年没有加班到这么晚才回家收拾好自己，马上5月了，到了5月来深圳就满整整四个年头了，我眨了眨眼睛,开始发发牢骚。 加班记忆很清晰，刚工作的时候我特别喜欢加班，为何？没钱，住的条件又差，握手楼，屋里没空调，别提多热了，人又比较胖，心想还不如在公司加班，有空调，还能给领导营造出一种你特别努力的工作状态，美哉。 然而实际情况是啥？ 代码写的烂，下什么班啊接着改BUG，由于代码设计不合理，需求频繁变动导致需要推翻之前架构，频繁返工。 既然已经这样了那就干脆更乱一点吧。懒得管了 拿着一个需求直接开始写，不做需求分析。 以上种种情况下还得按时交货，那肯定得加班。 而如今工作已三年有余，生活质量远不像以前那样将就，希望工作之外有较多的私人时间充电,多锻炼,毕竟身体好才是对自己，家人负责。 工作入职了新公司，特别特别小的创业公司，刚好入职的一段时间公司短时间内接了很多项目，服务对方过程中爆发出了一系列问题，老板临时晚上开了个会，会上我表达了一下自己的看法，项目管理上面很乱，很没有章法，服务对象短时间爆发式增长，现有系统架构不稳定，不过想来也是情有可原，毕竟基本都身兼数职，这也就是为什么今天回来的这么晚的原因了。 虽然刚入职不过也算是干了点事，毕竟谁都会背一点技术债，比如以前流程上的不规范，引入新流程，修复潜在漏洞等。 入职不久就启动了一个海外项目，分析完需求之后开始在参考Github上面一些比较出名库的架构，之后用了差不多一周的时间写SDK，基本也是跟自己预估的时间差不多，节奏控制的特别好，基本下班就走。这也是我比较纠结的一个点了，公司基本我走最早，其余都加班，有一个是刚毕业的能力方面可能有所欠缺，加加班也是应该，后来了解到原来其余的都是一起出来创业的 效率加班说明你没有效率 在我看来是这样的，并且非常认同这一句话，如果一天按时完成了工作任务何来加班！ 可是我从创业者角度来看，是这样吗？ 不是 事情做不完。永远做不完 我已入职快一个月了，基本上在coding期间会插进来各种事情，被动的不说，主动方面，由于公司网络库非常老旧，不方便维护，从长远考虑自己写了一个网络库，文档方面又非常散，对外推的时候需要手动给对方，而不是让使用者自主寻找文档，所以自己通过Github pages，找公司要了一个域名，做一个静态网页，管理对外文档，要知道我手上可是有开发任务的，所以比较难专注的去做一件事。 再比如跟我对接的后台，公司基本所有问题都要经他流转，东一下西一下的帮业务处理一些问题，关键还有自己的开发任务。 总之负责的业务越多，精力可能越分散也就无法做好一件事情，出现问题的几率也就越大。 生活关于生活不想说一些生活琐事，而想说说我发生的一些变化。 一个需求动手之前都会想想为何？此事何来？何以见得？ 因为我需要一个合理解释来说服我。 以后再写吧，该睡了 安]]></content>
      <categories>
        <category>日常侃侃</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 所谓的动态创建Application的方式]]></title>
    <url>%2F2018%2F04%2F08%2FAndroid%20%E6%89%80%E8%B0%93%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAApplication%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于需求在不调用代码的情况下，完成SDK初始化以及请求广告开屏广告操作。 拿到这个需求的时候很疑惑，为什么不能调用代码，是考虑到接入我们SDK成本太高？不存在的，SDK的接入都会给使用者详细的文档按照文档接入即可。我提出了我的质疑。甚至觉得这是一个伪需求 然而给我的答案仅仅是优化我们的接入方式。(这就是个伪需求) 怎么做当确定了需求之后我立即着手该怎么而后确定了大致思路 在Manifest里面声明SDK的代理Application累，替换原有的Application，当创建SDK的代理类Application的时候手动初始化我们的SDK，然后使用hook方式启动一个SDK内置WelcomeActivity，请求广告吸附在该WelcomeActivit上面，随后控制其Activity声明周期创建/销毁 关联 广告展示/关闭等周期。 我们知道Android Application 创建的方式即在Manifest里面声明一个name属性即可创建代码如下1234567&lt;application android:name=".sample.MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 对应的继承Application则会被调用。 如果要实现所谓的‘动态替换’Application得从这里入手了。 实现首先在Manifest声明自己的Application类 包名(也就是路径)123&lt;meta-data android:name="APPLICATION_NAME" android:value="com.jadx.android.sample.MyApplication" /&gt; 而后application name属性声明成SDK代理类Application1234567&lt;application android:name=".ProxyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 在该代理类里面生成真的Application并且实现一系列代理方法核心代码如下 12345678910111213141516171819202122232425262728@Override public void onCreate() &#123; super.onCreate(); mContext = this; final String name = getAppName(); if (!TextUtils.isEmpty(name)) &#123; try &#123; Class clazz = Class.forName(name); mRealApplication = (Application) clazz.newInstance(); mRealApplication.onCreate(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public String getAppName() &#123; try &#123; ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo( mContext.getPackageName(), PackageManager.GET_META_DATA); if (appInfo.metaData != null) &#123; return appInfo.metaData.getString(APP_NAME_KEY); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; return ""; &#125; 当App启动时会走代理类ProxyApplication的OnCreate方法而后通过Class.forName(“包名.类名”)获得其实例，随后代理其一系列原有方法即可。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OkHttp网络请求的封装]]></title>
    <url>%2F2018%2F04%2F06%2FAndroid-OkHttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Github添加依赖12345678implementation 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'implementation 'com.squareup.okhttp3:okhttp:3.5.0'orcomplie 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'compile 'com.squareup.okhttp3:okhttp:3.5.0' Feature 支持JSON解析CallBack声明泛型即可 UI线程回调 支持文件下载 支持Activity/fragment绑定生命周期 支持自定义解析内容 如功能不够，可拿到原生Client，自定义功能 请求Get123456789101112OkHttpRun.get(GET) .execute(new StringCallBack() &#123; @Override public void onSuccess(Call call, String response) &#123; mTextView.setText(response); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); POST12345678910111213OkHttpRun.post(POST).addParams("name", "xwd") .addParams("pwd", "123") .execute(new JsonCallBack&lt;Token&gt;() &#123; @Override public void onSuccess(Call call, Token response) &#123; mTextView.setText(response.toString()); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 下载文件12345678910111213141516171819202122232425String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + "com.test"; OkHttpRun.get("http://download.kugou.com/download/kugou_android") //path 文件路径 // 文件名称 .execute(new FileCallBack&lt;File&gt;(path, "temp.apk") &#123; @Override protected void onProgressListener(float current, long total) &#123; LOG.w("TAG", "current " + current * 100 + "/" + " " + total); &#125; @Override protected void onFinish(File file) &#123; LOG.w("TAG", "finish"); &#125; @Override protected void onStart() &#123; LOG.w("TAG", "start"); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 解析默认支持Callback如下 StringCallBack JsonCallBack FileCallBack 如需要其他解析扩展，继承AbstractCallBack 即可比如123456789101112public abstract class StringCallBack extends AbstractCallBack&lt;String&gt; &#123; @Override protected String parser(Call call, Response response) throws IOException &#123; final String result = response.body().string(); onSuccess(call, result); return result; &#125; protected abstract void onSuccess(Call call, String response);&#125; 配置OkHttpClient添加拦截器到默认client123456789101112final Interceptor interceptor = new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; ... return chain.proceed(requestBuilder.build()); &#125; &#125;; //最后build一下 HttpManager.getInstance().addInterceptor(interceptor) .addNetworkInterceptor(); .build(); 获取内置OkHttpClient1HttpManager.getInstance().getDefaultClient(); 设置OKHttpClient1HttpManaget.getInstance().setOkHttpClient();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android第三方库源码分析,以及Gradle学习资料(持续更新)]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%B8%80%E4%BA%9BAndroid%E7%AC%AC%E4%B8%89%E6%96%B9Lib%E8%A7%A3%E6%9E%90%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[网络库系列 OKHttp拆轮子系列 OkHttp源码解析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 工厂方法模式]]></title>
    <url>%2F2018%2F03%2F03%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪个类 而工厂方法模式有一套通用模式代码 定义zoo类如下: 1234public abstract class Zoo &#123; public abstract void showAnimal();&#125; dog类如下: 1234567public class Dog extends Zoo &#123; @Override public void showAnimal() &#123; System.out.println("dog is show"); &#125;&#125; pig类如下: 123456public class Pig extends Zoo &#123; @Override public void showAnimal() &#123; System.out.println("pig is show"); &#125;&#125; 定义一个工厂方法接口: 1234public interface Factory &#123; Zoo createAnimal();&#125; 实现类: 1234567public class ClientFactory implements Factory &#123; @Override public Zoo createAnimal() &#123; return new Dog(); //return new Pig(); &#125;&#125; 123456public static void main(String[] arg)&#123; Factory factory = new ClientFactory(); Dog zoo = (Dog) factory.createAnimal(); // or Pig pig = (Pig) factory.createAnimal(); zoo.showAnimal();&#125; 输出结果 1dog is show 需要哪一个类的对象就传入哪一个类的类型即可，这种方法比较简洁，动态。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 代理模式]]></title>
    <url>%2F2018%2F02%2F27%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为其他对象提供一种代理一控制对这个对象的访问。 场景当不想直接访问某个对象或访问某个对象存在着一定困难时就可以通过一个代理对象来间接访问。 Code1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String args[]) &#123; // 通过代理类访问具体执行发送信息对象 ProxyMessage proxy = new ProxyMessage(); proxy.sendMessage("Android"); &#125; //代理类 static class ProxyMessage &#123; final Message mMessage = new Message(); void sendMessage(String type) &#123; if ("Android".equals(type)) &#123; mMessage.sendAndroid(); &#125; else &#123; mMessage.sendIOS(); &#125; &#125; &#125; public static class Message &#123; void sendAndroid() &#123; System.out.println("send Android"); &#125; void sendIOS() &#123; System.out.println("send ios"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android关于LayoutInflater加载布局导致布局宽高失效]]></title>
    <url>%2F2018%2F02%2F26%2FAndroid%E5%85%B3%E4%BA%8ELayoutInflater%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80%E5%AF%BC%E8%87%B4%E5%B8%83%E5%B1%80%E5%AE%BD%E9%AB%98%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[为何宽高失效？想要实现如下效果只需要一个recyclerView里面一个textView即可。 Adapter 代码 123456789101112131415161718192021222324252627282930313233343536373839static class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mStrings = new ArrayList&lt;&gt;(); public MyAdapter(Context context) &#123; mContext = context; for (int i = 0; i &lt; 20; i++) &#123; mStrings.add("" + i); &#125; &#125; @Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); return new MyHolder(view); &#125; @Override public void onBindViewHolder(MyHolder holder, int position) &#123; holder.mTextView.setText(mStrings.get(position)); &#125; @Override public int getItemCount() &#123; return mStrings.size(); &#125; static class MyHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyHolder(View itemView) &#123; super(itemView); mTextView = itemView.findViewById(R.id.text); &#125; &#125; &#125; xml文件如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/black" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:padding="12dp" android:layout_height="wrap_content" android:textColor="@android:color/white" android:gravity="center" android:text="123123"/&gt; &lt;/LinearLayout&gt; 可是实现的效果是这样的 可以看到宽明明是match _ parent但是在这里却变成了wrap_content,即文本长度多长，textView宽度都宽，为什么会失效呢？ 首先一个View的宽高padding什么的失我第一个想到的就是LayoutParams，因为一些xml里面属性都在LayoutParams里面，如果失效了估计是LayoutParams没有set上去。 关于LayoutInflater123LayoutInflater.from(mContext).inflate(R.layout.item_list, null);LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 以上是最为普通使用LayoutInflater加载Layout方式，上面的列子中如果使用了3个参数的方法来加载Layout，也就解决了宽度问题，搞懂了2个参数和3个参数方法的区别也就明白了。 代码如下 12345@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, parent, false); return new MyHolder(view); &#125; 如上也就解决了宽度失效问题，可是为什么呢？ 源码 1234567891011121314/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy. * @return The root View of the inflated hierarchy. If root was supplied, * this is the root View; otherwise it is the root of the inflated * XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; 本质上2个参数的方法也是调用了3个参数的方法。三个参数源码如下 1234567891011121314151617181920212223242526272829303132/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; //解析xml final XmlResourceParser parser = res.getLayout(resource); try &#123; //inflate的地方 return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; * &lt;em&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;For performance * reasons, view inflation relies heavily on pre-processing of XML files * that is done at build time. Therefore, it is not currently possible to * use LayoutInflater with an XmlPullParser over a plain XML file at runtime. * * @param parser XML dom node containing the description of the view * hierarchy. * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... 省略部分代码 if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; // 判断是否是merge标签 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); // 关键点 ViewGroup.LayoutParams params = null; // parent 是否为空 if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied // 创建跟布局的LayoutParams params = root.generateLayoutParams(attrs); // 是否为false 如果是flase则添加到view里面 if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. // 注意到这里如果是true 则会将其View添加到root里面 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ... 省略部分代码 return result; &#125; &#125; 注意看到判断是否MERGE的else分支，里面关键的地方都已经写上注释。 其实也就是说，如果root不是空的话，回去创建LayoutParams，在判断如果attchToRoot参数如果是false，则会setLayoutParams到View里面去。 文章的开头有说到LayoutParams这个类，里面都是一个在xml声明的属性，那我们尝试的从侧门解决一下问题，看如下代码 123456@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); view.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); return new MyHolder(view); &#125; 我手动为其设置了LayoutParams，结果如何呢？如下 一样的。 为什么失效之后又是wrap_content呢？这是因为RecyclerView里面机制如果LayoutParams是空的会给一个默认的LayoutParams。以后有兴趣贴源码。 总结12345// 只会生成View 并不会设置任何属性LayoutInflater.from(mContext).inflate(R.layout.item_list, null);// 如果parent不为空会为其生成LayoutParams属性，// attchToRoot如果为flase则会将LayoutParams Set进去，如果为true，则会添加到root里面LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 分割线这种问题其实在开发中非常常见不过当时解决了之后并没有深究其原因实属不该。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 Builder模式]]></title>
    <url>%2F2018%2F02%2F25%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍Builder模式是一步一步创建一个复杂对象的创建型模式，可以更精细的控制对象的构造流程。 使用场景 当初始化一个对象特别复杂，比如说参数多，且很多参数都具有默认值 多个部件或者零件，都可以组装到同一个对象中，但是产生的运行结果又不相同。 实现12345678910111213141516171819202122232425262728293031323334public static class Builder &#123; private ViewStub mEmptyViewStub; private ViewStub mLoadingViewStub; private ViewStub mFailureViewStub; private Context mContext; public Builder(Context context) &#123; mContext = context; &#125; public Builder setEmptyViewId(@LayoutRes int resId) &#123; mEmptyViewStub = new ViewStub(mContext); mEmptyViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingLayoutId(@LayoutRes int resId) &#123; mLoadingViewStub = new ViewStub(mContext); mLoadingViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingFailureId(@LayoutRes int resId) &#123; mFailureViewStub = new ViewStub(mContext); mFailureViewStub.setLayoutResource(resId); return this; &#125; public XwStateLayoutManager build() &#123; return new XwStateLayoutManager(this); &#125; &#125; 以上代码是构建通用布局所需要的零件，所以采用了Builder模式来构建所需要的零件 Android 源码实现可参考AlertDialog.Builder 实现。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxAndroid 常用操作符记录]]></title>
    <url>%2F2018%2F01%2F26%2FRxAndroid-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[map,filter,操作符区别？12345678910111213141516171819202122232425//mapObservable.just(mIntegers). map(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; list) &#123; // 做想做的操作 int number = list.get(i); return nulber == 2; &#125; &#125;).subscribe(new Observer&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Boolean aBoolean) &#123; Log.d("TAG", "A = " + aBoolean); &#125; &#125;); 1234567891011121314151617181920212223//filter Observable.just(mIntegers).filter(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; integers) &#123; final int b = integers.get(3); return b &gt; 10; &#125; &#125;).subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; print("size = " + integers.size()); &#125; &#125;); 注意以上代码结果，无论map操作符结果是ture，还是false，订阅者observer都会收到方法回调。 而filter不一样，如果不满足条件observer是不会收到方法回调。 flatMap1234567891011121314151617181920212223242526Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); flatMap 操作符实际上是一个一对多的转换，结合如上业务代码很好理解 根据token去获取到所有的用户信息，查询大于15岁的的用户信息，最后返回一个用户信息集合给订阅者。 flatMap 会返回一个Obervable流，而不像map操作符返回的是一对一的结果。 线程调度在如上列子中，是一个同步任务列子，如何制定为异步任务的话很可能会导致卡顿，那么这里就需要使用大Rx非常强大的线程调度,并且特别方便。先看如下代码 12345678910111213141516171819202122232425262728Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); 注意两个概念 subscribeOn : 指定其事件产生线程 observeOn : 指定事件消费线程 12.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) 如上两句代码则完成线程的切换工作。 如果存在多个observable事件源如何切换线程?12345678910111213141516171819202122232425262728293031Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); // 省略判断条件 return Observale.just(mGirls).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); 如上代码subscribeOn调用了2次flatMap流指定生产线程为异步线程，而filter流指定了生产线程为主线程最后看一下输出结果： 123com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次. 注意： subscribeOn的调用切换之前的线程。 observeOn的调用切换之后的线程。 observeOn之后，不可再调用subscribeOn 切换线程 看如下代码log如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); return Observable.just(users).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()).observeOn(Schedulers.io()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(new Func1&lt;List&lt;User&gt;, String&gt;() &#123; @Override public String call(List&lt;User&gt; users) &#123; print("3 = " + (Looper.getMainLooper() == Looper.myLooper())); return "1"; &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: 3 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 即使在最后一个map指定subscribeOn线程为IO，打印出来还是在主线程。observeOn之后再次调用 subscribeOn是无效的参考文章 http://blog.csdn.net/jdsjlzx/article/details/51685769]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 带三角形箭头头的指引TipLayout实现]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid-%E5%B8%A6%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%8C%87%E5%BC%95tipLayout%E5%AE%9E%E7%8E%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[如上设计图，要求三角形指示器需要动态对齐上面的文本，需要动态的实现对其三角形。 引用方式123compile 'com.xiaowei:TriangleTipLayout:1.0.1'//orimplementation 'com.xiaowei:TriangleTipLayout:1.0.1' 实现思路准备一个三角形指引的图片即可。先上代码 12345678910111213141516171819202122232425262728final TextPaint textPaint = mTextView.getPaint(); final int textHeight = (int) (textPaint.descent() - textPaint.ascent()); mRect.set(0, DEFAULT_TOP_HEIGHT, getWidth(), getHeight() + textHeight - DEFAULT_TOP_HEIGHT); canvas.drawRect(mRect, mRectPaint); final String text = mTextView.getText().toString(); float left = 0; if (mIsShowTriangle) &#123; if (mGravity == Gravity.LEFT || mGravity == Gravity.START) &#123; LayoutParams layoutParams = (LayoutParams) mTarget.getLayoutParams(); left = mTarget.getLeft() - layoutParams.rightMargin - layoutParams.leftMargin; &#125; else &#123; if (mTarget instanceof TextView) &#123; ViewParent viewParent = mTarget.getParent(); float textWidth = textPaint.measureText(text); if (viewParent instanceof LinearLayout) &#123; final float width = mTarget.getWidth() / 2; left = mTarget.getLeft() + width - (mBitmap.getWidth() / 2); &#125; else if (viewParent instanceof RelativeLayout) &#123; left = mTarget.getLeft() + textWidth / 2; &#125; &#125; else if (mTarget instanceof ImageView) &#123; final float width = mTarget.getWidth(); left = mTarget.getLeft() + (width / 2) - (mBitmap.getWidth() / 2); &#125; &#125; canvas.drawBitmap(mBitmap, left, 0, mBitmapPaint); &#125; &#125; 核心代码如上,其思路是先绘制一个矩形，预留出三角形指示器图片所需要的高度，最后将其三行图片绘制出来。 配置指示器123456mTipsLayout.setRectBackgroundColor(Color.parseColor("#FFF8BE"));mTipsLayout.setTextColor(Color.parseColor("#FF9B33"));mTipsLayout.setTriangleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_triangle_arrow));mTipsLayout.setTriangleGravity(Gravity.START);mTipsLayout.bindView(findViewById(R.id.text2));mTipsLayout.setText("您今日收入已到达10W+，牛逼。保持努力"); 注意：当调用setText之后会invalidate()重新绘制; 实现效果如下: Feature todo About GitHub:Github/xwdz/TriangleTipLayout]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Day]]></title>
    <url>%2F2018%2F01%2F01%2FFirst-Day%2F</url>
    <content type="text"><![CDATA[只有当紫霞仙子离开至尊宝的时候，他才能变孙悟空。]]></content>
      <categories>
        <category>日常侃侃</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android studio发布个人开源项目至bintray]]></title>
    <url>%2F2017%2F11%2F12%2FAndroidStudio%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91bintray%2F</url>
    <content type="text"><![CDATA[创建账号创建账号时要注意要用国外邮箱。 使用插件发布 项目根目录 build.gradle 添加引用 1classpath 'com.novoda:bintray-release:0.3.4' library目录下的build.gradle 配置如下信息 1234567891011121314151617181920apply plugin: 'com.android.library'//添加如下引用apply plugin: 'com.novoda.bintray-release'//def siteUrl = 'https://github.com/xwdz/BarChartView'publish &#123; userOrg = 'quinnhuang'//bintray.com的用户名 repoName = 'xw-widget'//远程仓库名字,不指明，默认是上传到maven groupId = 'com.xiaowei'//jcenter上的路径 artifactId = 'barchart-view'//项目名称 publishVersion = '1.0.0'//版本号 desc = '轻量型柱形图'//描述，不重要 website = siteUrl//项目主页&#125;tasks.withType(Javadoc) &#123;//防止编码问题 options.addStringOption('Xdoclint:none', '-quiet') options.addStringOption('encoding', 'UTF-8') options.addStringOption('charSet', 'UTF-8')&#125; 上传至bintray1./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxxx -PdryRun=falser 期间遇到的问题用户名不统一1Could not create version '1.0.0': HTTP/1.1 401 Unauthorized PbintrayUser、userOrg 两者属性属性必须一样，即bintray.com的用户名 lint 检查出来的错误12345android &#123; lintOptions &#123; abortOnError false &#125; &#125; 在你library以及App的build.gradle的androud模块添加 123456789101112131415161718192021222324android &#123; compileSdkVersion 26 buildToolsVersion "26.0.0" defaultConfig &#123; minSdkVersion 21 targetSdkVersion 26 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; // 忽略lint lintOptions &#123; abortOnError false &#125;&#125; 最后add central 等待审核即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio .9图]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-studio-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[生成.9图Android Studio 对于.9图的生成也非常友好，直接点击图片右建create.9图； 图片右键 =&gt; Create 9-patch File =&gt; 确定即可，生成.9图之后打开即如见下图 文件名会默认为：xxx.9.png 如上图4条黑线位置构成拉伸区域]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 混淆相关]]></title>
    <url>%2F2017%2F10%2F03%2FAndroid-%E6%B7%B7%E6%B7%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[忽略tmp.txt tmp.txt 忽略所有log文件 .log 忽略tmp文件夹所有文件 tmp/* 忽略log目录下的包括子目录下的所有log文件 log/**/*.log 查看项目ＳＨＡ１ ＭＤ５ 值 keytool -v -list -keystore ~/.android/debug.keystore]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令记录]]></title>
    <url>%2F2017%2F10%2F03%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[删除本地分支 git branch -d 分支名 删除未合并分支 git branch -D 分支名 新建本地分支 git branch 分支名 推送分支到服务器 git push origin 本地分支名:服务器分支名 删除远程分支 git push origin --delete &lt;branchName&gt; git 回退commit首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本. 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 $ git reset --hard HEAD^ 版本比对git diff commitMD5 git工作流当release分支结束时，使用gitflow，finish掉分支 git flow release finish &#39;1.1&#39;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
